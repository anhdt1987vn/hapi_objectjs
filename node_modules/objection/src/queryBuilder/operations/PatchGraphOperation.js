import _ from 'lodash';
import Promise from 'bluebird';
import RelationExpression from '../RelationExpression';
import DelegateOperation from './DelegateOperation';
import UpdateOperation from './UpdateOperation';

import insertFuncBuilder from '../graphInserter/inserter';
import GraphInserter from '../graphInserter/GraphInserter';

export default class PatchGraphOperation extends DelegateOperation {

  constructor(name, opt) {
    super(name, opt);

    if (!this.delegate.is(UpdateOperation)) {
      throw new Error('Invalid delegate');
    }

    // Our delegate operation inherits from `UpdateOperation`. Disable the call-time
    // validation. We do the validation in onAfterQuery instead.
    this.delegate.modelOptions.skipValidation = true;
  }

  get model() {
    return this.delegate.model;
  }

  call(builder, args) {
    const retVal = super.call(builder, args);

    // We resolve this query here and will not execute it. This is because the root
    // value may depend on other models in the graph and cannot be inserted first.
    builder.resolve([]);

    return retVal;
  }

  onBeforeInternal() {
    // Do nothing. We override this with empty implementation so that
    // the $beforeUpdate() hooks are not called twice for the root models.
  }

  onBuild() {
    // Do nothing.
  }

  // We overrode all other hooks but this one and do all the work in here.
  // This is a bit hacky.
  onAfterQuery(builder) {
    const eager = RelationExpression.fromGraph(this.model);

    return builder
      .modelClass()
      .query()
      .childQueryOf(builder)
      .copyFrom(builder, /where/)
      .eager(eager)
      .then(function (models) {
        let fetched;

        if (Array.isArray(models)) {
          if (models.length > 1) {
            throw new Error('A query with `patchGraph` resulted in multiple rows. `patchGraph` can only be applied to queries that result in a single row.')
          }

          fetched = models[0];
        } else {
          fetched = models;
        }

        console.log(models);
      });
  }

  onAfterInternal() {
    return this.model;
  }
}
