'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _RelationExpression = require('../RelationExpression');

var _RelationExpression2 = _interopRequireDefault(_RelationExpression);

var _DelegateOperation2 = require('./DelegateOperation');

var _DelegateOperation3 = _interopRequireDefault(_DelegateOperation2);

var _UpdateOperation = require('./UpdateOperation');

var _UpdateOperation2 = _interopRequireDefault(_UpdateOperation);

var _inserter = require('../graphInserter/inserter');

var _inserter2 = _interopRequireDefault(_inserter);

var _GraphInserter = require('../graphInserter/GraphInserter');

var _GraphInserter2 = _interopRequireDefault(_GraphInserter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PatchGraphOperation = function (_DelegateOperation) {
  (0, _inherits3.default)(PatchGraphOperation, _DelegateOperation);

  function PatchGraphOperation(name, opt) {
    (0, _classCallCheck3.default)(this, PatchGraphOperation);

    var _this = (0, _possibleConstructorReturn3.default)(this, _DelegateOperation.call(this, name, opt));

    if (!_this.delegate.is(_UpdateOperation2.default)) {
      throw new Error('Invalid delegate');
    }

    // Our delegate operation inherits from `UpdateOperation`. Disable the call-time
    // validation. We do the validation in onAfterQuery instead.
    _this.delegate.modelOptions.skipValidation = true;
    return _this;
  }

  PatchGraphOperation.prototype.call = function call(builder, args) {
    var retVal = _DelegateOperation.prototype.call.call(this, builder, args);

    // We resolve this query here and will not execute it. This is because the root
    // value may depend on other models in the graph and cannot be inserted first.
    builder.resolve([]);

    return retVal;
  };

  PatchGraphOperation.prototype.onBeforeInternal = function onBeforeInternal() {
    // Do nothing. We override this with empty implementation so that
    // the $beforeUpdate() hooks are not called twice for the root models.
  };

  PatchGraphOperation.prototype.onBuild = function onBuild() {}
  // Do nothing.


  // We overrode all other hooks but this one and do all the work in here.
  // This is a bit hacky.
  ;

  PatchGraphOperation.prototype.onAfterQuery = function onAfterQuery(builder) {
    var eager = _RelationExpression2.default.fromGraph(this.model);

    return builder.modelClass().query().childQueryOf(builder).copyFrom(builder, /where/).eager(eager).then(function (models) {
      var fetched = void 0;

      if (Array.isArray(models)) {
        if (models.length > 1) {
          throw new Error('A query with `patchGraph` resulted in multiple rows. `patchGraph` can only be applied to queries that result in a single row.');
        }

        fetched = models[0];
      } else {
        fetched = models;
      }

      console.log(models);
    });
  };

  PatchGraphOperation.prototype.onAfterInternal = function onAfterInternal() {
    return this.model;
  };

  (0, _createClass3.default)(PatchGraphOperation, [{
    key: 'model',
    get: function get() {
      return this.delegate.model;
    }
  }]);
  return PatchGraphOperation;
}(_DelegateOperation3.default);

exports.default = PatchGraphOperation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlBhdGNoR3JhcGhPcGVyYXRpb24uanMiXSwibmFtZXMiOlsiUGF0Y2hHcmFwaE9wZXJhdGlvbiIsIm5hbWUiLCJvcHQiLCJkZWxlZ2F0ZSIsImlzIiwiRXJyb3IiLCJtb2RlbE9wdGlvbnMiLCJza2lwVmFsaWRhdGlvbiIsImNhbGwiLCJidWlsZGVyIiwiYXJncyIsInJldFZhbCIsInJlc29sdmUiLCJvbkJlZm9yZUludGVybmFsIiwib25CdWlsZCIsIm9uQWZ0ZXJRdWVyeSIsImVhZ2VyIiwiZnJvbUdyYXBoIiwibW9kZWwiLCJtb2RlbENsYXNzIiwicXVlcnkiLCJjaGlsZFF1ZXJ5T2YiLCJjb3B5RnJvbSIsInRoZW4iLCJtb2RlbHMiLCJmZXRjaGVkIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsIm9uQWZ0ZXJJbnRlcm5hbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7O0lBRXFCQSxtQjs7O0FBRW5CLCtCQUFZQyxJQUFaLEVBQWtCQyxHQUFsQixFQUF1QjtBQUFBOztBQUFBLCtEQUNyQiw4QkFBTUQsSUFBTixFQUFZQyxHQUFaLENBRHFCOztBQUdyQixRQUFJLENBQUMsTUFBS0MsUUFBTCxDQUFjQyxFQUFkLDJCQUFMLEVBQXdDO0FBQ3RDLFlBQU0sSUFBSUMsS0FBSixDQUFVLGtCQUFWLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0EsVUFBS0YsUUFBTCxDQUFjRyxZQUFkLENBQTJCQyxjQUEzQixHQUE0QyxJQUE1QztBQVRxQjtBQVV0Qjs7Z0NBTURDLEksaUJBQUtDLE8sRUFBU0MsSSxFQUFNO0FBQ2xCLFFBQU1DLFNBQVMsNkJBQU1ILElBQU4sWUFBV0MsT0FBWCxFQUFvQkMsSUFBcEIsQ0FBZjs7QUFFQTtBQUNBO0FBQ0FELFlBQVFHLE9BQVIsQ0FBZ0IsRUFBaEI7O0FBRUEsV0FBT0QsTUFBUDtBQUNELEc7O2dDQUVERSxnQiwrQkFBbUI7QUFDakI7QUFDQTtBQUNELEc7O2dDQUVEQyxPLHNCQUFVLENBRVQ7QUFEQzs7O0FBR0Y7QUFDQTs7O2dDQUNBQyxZLHlCQUFhTixPLEVBQVM7QUFDcEIsUUFBTU8sUUFBUSw2QkFBbUJDLFNBQW5CLENBQTZCLEtBQUtDLEtBQWxDLENBQWQ7O0FBRUEsV0FBT1QsUUFDSlUsVUFESSxHQUVKQyxLQUZJLEdBR0pDLFlBSEksQ0FHU1osT0FIVCxFQUlKYSxRQUpJLENBSUtiLE9BSkwsRUFJYyxPQUpkLEVBS0pPLEtBTEksQ0FLRUEsS0FMRixFQU1KTyxJQU5JLENBTUMsVUFBVUMsTUFBVixFQUFrQjtBQUN0QixVQUFJQyxnQkFBSjs7QUFFQSxVQUFJQyxNQUFNQyxPQUFOLENBQWNILE1BQWQsQ0FBSixFQUEyQjtBQUN6QixZQUFJQSxPQUFPSSxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGdCQUFNLElBQUl2QixLQUFKLENBQVUsK0hBQVYsQ0FBTjtBQUNEOztBQUVEb0Isa0JBQVVELE9BQU8sQ0FBUCxDQUFWO0FBQ0QsT0FORCxNQU1PO0FBQ0xDLGtCQUFVRCxNQUFWO0FBQ0Q7O0FBRURLLGNBQVFDLEdBQVIsQ0FBWU4sTUFBWjtBQUNELEtBcEJJLENBQVA7QUFxQkQsRzs7Z0NBRURPLGUsOEJBQWtCO0FBQ2hCLFdBQU8sS0FBS2IsS0FBWjtBQUNELEc7Ozs7d0JBckRXO0FBQ1YsYUFBTyxLQUFLZixRQUFMLENBQWNlLEtBQXJCO0FBQ0Q7Ozs7O2tCQWhCa0JsQixtQiIsImZpbGUiOiJQYXRjaEdyYXBoT3BlcmF0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBQcm9taXNlIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCBSZWxhdGlvbkV4cHJlc3Npb24gZnJvbSAnLi4vUmVsYXRpb25FeHByZXNzaW9uJztcbmltcG9ydCBEZWxlZ2F0ZU9wZXJhdGlvbiBmcm9tICcuL0RlbGVnYXRlT3BlcmF0aW9uJztcbmltcG9ydCBVcGRhdGVPcGVyYXRpb24gZnJvbSAnLi9VcGRhdGVPcGVyYXRpb24nO1xuXG5pbXBvcnQgaW5zZXJ0RnVuY0J1aWxkZXIgZnJvbSAnLi4vZ3JhcGhJbnNlcnRlci9pbnNlcnRlcic7XG5pbXBvcnQgR3JhcGhJbnNlcnRlciBmcm9tICcuLi9ncmFwaEluc2VydGVyL0dyYXBoSW5zZXJ0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRjaEdyYXBoT3BlcmF0aW9uIGV4dGVuZHMgRGVsZWdhdGVPcGVyYXRpb24ge1xuXG4gIGNvbnN0cnVjdG9yKG5hbWUsIG9wdCkge1xuICAgIHN1cGVyKG5hbWUsIG9wdCk7XG5cbiAgICBpZiAoIXRoaXMuZGVsZWdhdGUuaXMoVXBkYXRlT3BlcmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlbGVnYXRlJyk7XG4gICAgfVxuXG4gICAgLy8gT3VyIGRlbGVnYXRlIG9wZXJhdGlvbiBpbmhlcml0cyBmcm9tIGBVcGRhdGVPcGVyYXRpb25gLiBEaXNhYmxlIHRoZSBjYWxsLXRpbWVcbiAgICAvLyB2YWxpZGF0aW9uLiBXZSBkbyB0aGUgdmFsaWRhdGlvbiBpbiBvbkFmdGVyUXVlcnkgaW5zdGVhZC5cbiAgICB0aGlzLmRlbGVnYXRlLm1vZGVsT3B0aW9ucy5za2lwVmFsaWRhdGlvbiA9IHRydWU7XG4gIH1cblxuICBnZXQgbW9kZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubW9kZWw7XG4gIH1cblxuICBjYWxsKGJ1aWxkZXIsIGFyZ3MpIHtcbiAgICBjb25zdCByZXRWYWwgPSBzdXBlci5jYWxsKGJ1aWxkZXIsIGFyZ3MpO1xuXG4gICAgLy8gV2UgcmVzb2x2ZSB0aGlzIHF1ZXJ5IGhlcmUgYW5kIHdpbGwgbm90IGV4ZWN1dGUgaXQuIFRoaXMgaXMgYmVjYXVzZSB0aGUgcm9vdFxuICAgIC8vIHZhbHVlIG1heSBkZXBlbmQgb24gb3RoZXIgbW9kZWxzIGluIHRoZSBncmFwaCBhbmQgY2Fubm90IGJlIGluc2VydGVkIGZpcnN0LlxuICAgIGJ1aWxkZXIucmVzb2x2ZShbXSk7XG5cbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG5cbiAgb25CZWZvcmVJbnRlcm5hbCgpIHtcbiAgICAvLyBEbyBub3RoaW5nLiBXZSBvdmVycmlkZSB0aGlzIHdpdGggZW1wdHkgaW1wbGVtZW50YXRpb24gc28gdGhhdFxuICAgIC8vIHRoZSAkYmVmb3JlVXBkYXRlKCkgaG9va3MgYXJlIG5vdCBjYWxsZWQgdHdpY2UgZm9yIHRoZSByb290IG1vZGVscy5cbiAgfVxuXG4gIG9uQnVpbGQoKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfVxuXG4gIC8vIFdlIG92ZXJyb2RlIGFsbCBvdGhlciBob29rcyBidXQgdGhpcyBvbmUgYW5kIGRvIGFsbCB0aGUgd29yayBpbiBoZXJlLlxuICAvLyBUaGlzIGlzIGEgYml0IGhhY2t5LlxuICBvbkFmdGVyUXVlcnkoYnVpbGRlcikge1xuICAgIGNvbnN0IGVhZ2VyID0gUmVsYXRpb25FeHByZXNzaW9uLmZyb21HcmFwaCh0aGlzLm1vZGVsKTtcblxuICAgIHJldHVybiBidWlsZGVyXG4gICAgICAubW9kZWxDbGFzcygpXG4gICAgICAucXVlcnkoKVxuICAgICAgLmNoaWxkUXVlcnlPZihidWlsZGVyKVxuICAgICAgLmNvcHlGcm9tKGJ1aWxkZXIsIC93aGVyZS8pXG4gICAgICAuZWFnZXIoZWFnZXIpXG4gICAgICAudGhlbihmdW5jdGlvbiAobW9kZWxzKSB7XG4gICAgICAgIGxldCBmZXRjaGVkO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1vZGVscykpIHtcbiAgICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBxdWVyeSB3aXRoIGBwYXRjaEdyYXBoYCByZXN1bHRlZCBpbiBtdWx0aXBsZSByb3dzLiBgcGF0Y2hHcmFwaGAgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBxdWVyaWVzIHRoYXQgcmVzdWx0IGluIGEgc2luZ2xlIHJvdy4nKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZldGNoZWQgPSBtb2RlbHNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hlZCA9IG1vZGVscztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKG1vZGVscyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIG9uQWZ0ZXJJbnRlcm5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbDtcbiAgfVxufVxuIl19